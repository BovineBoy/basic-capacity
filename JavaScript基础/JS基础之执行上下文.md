# 深入JS基础之执行上下文复习

##  什么是执行上下文

> 执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。全局对象可以被调用生成执行上下文，而一个普通函数也可以被调用生成执行上下文

## JS执行上下文的类型

在Javascript中，一共有三种执行上下文：

- **全局执行上下文**：只有一个，浏览器中的全局对象是`window`对象(node中是`global`)，JS解释器初始化执行代码时，this会指向这个window对象。
- **函数执行上下文**：有无数个，每当函数被调用就会创建对应函数的执行上下文
- **Eval函数执行上下文**：指运行在Eval函数中的代码，不推荐使用

## 执行上下文栈

- 当JavaScript代码执行的时候，会进入不同的执行上下文，这些执行上下文会构成了一个执行上下文栈。栈底永远都是全局上下文，而栈顶就是当前**正在执行**的上下文。

- 每当JavaScript代码执行上述执行上下文环境的代码时，就生成了对应环境的上下文，压入执行上下文栈(push)，**当栈顶的上下文执行完毕后，会自动出栈**(pop)。

- 一个执行上下文可以激活另一个执行上下文，比如一个函数调用另一个函数，或全局上下文调用了一个全局函数，然后一层层调用下去，激活其他上下文的某个上下文叫做`调用者caller`，被激活的上下文叫做`被调用者callee`，被调用者也可能是一个`caller`，比如全局函数中调用自己的内部方法。
- 当一个`caller`激活了一个`callee`，那么这个`caller`就会暂停自身执行，将执行上下文控制权交给`callee`(也就是当前执行上下文的**下一个**执行上下文)，这个`callee`就会被放入堆栈，被称为执行中的执行上下文。当这个`callee`上下文结束后，会把控制权再次交给他的`caller`，然后`caller`会在刚才暂停的地方继续执行。当这个`caller`结束执行后，会被**pop**出执行上下文栈，继续触发其他的执行上下文，一个`callee`可以用`return`或者`throw Error`的方式来结束自身上下文。

举个🌰：

```javascript
function fun2() {
  const b = 222;
}
function fun1() {
  fun2();
  const a = 111;
}
function fun3() {
  const c = 333
  console.log(c)
}
fun1();
fun3();
```

1. 开始执行；

   <-------栈顶----- 全局上下文  -----栈底 ------->

2. 代码执行到`fun1()`时，`全局上下文`为`caller`，`fun1`为`callee`，`全局上下文`暂停执行，创建`fun1`的执行上下文，`push`进执行上下文栈；

   <---栈顶-----  fun1执行上下文/全局上下文  -----栈底 --->

3. 代码执行到`fun1`函数内部的`fun2()`，此时`fun1`为`caller`，`fun2`为`callee`，`fun1`暂停执行，此时访问`变量a`，会报`a is not defined`，创建`fun2`的执行上下文，`push`进执行上下文栈；

   <---栈顶-----  fun2执行上下文/fun1执行上下文/全局上下文  -----栈底 --->

4. `fun2`执行完毕，`fun2执行上下文`从执行上下文栈中`pop`，`fun1`继续执行，创建`变量a`并赋值；

   <---栈顶-----  fun1执行上下文/全局上下文  -----栈底 --->

5. `fun1`执行完毕，`fun1执行上下文`从执行上下文栈中`pop`;

   <---栈顶----- 全局上下文  -----栈底 --->

6. `全局上下文`继续执行，执行到`fun3()`，`全局上下文`为`caller`，`fun3`为`callee`，`全局上下文`暂停执行，创建`fun3`的执行上下文，`push`进执行上下文栈；

   <---栈顶-----  fun3执行上下文/全局上下文  -----栈底 --->

7. `fun3`执行完毕，`fun3执行上下文`从执行上下文栈中`pop`，此时`全局上下文`执行完毕，但是会一直放在栈底；

   <-------栈顶----- 全局上下文  -----栈底 ------->

## 深入执行上下文

### 执行上下文的构成

通常我们把执行上下文抽象成一个有三个属性的对象：

```javascript
contextObj = {
  ThisBinding: {}, //this
	LexicalEnvironment: {/* 上下文自身变量对象+所有父执行上下文的变量对象 */}, //词法环境
  VariableEnvironment: {/* 函数arguments参数，内部变量和函数声明 */} //变量环境
}
```

### 执行上下文的产生

执行上下文分两个阶段创建：**1）创建阶段；** **2）执行阶段**

#### 创建阶段

- 1、确定 **this** 的值，也被称为 **This Binding**。
- 2、**LexicalEnvironment（词法环境）** 组件被创建。
- 3、**VariableEnvironment（变量环境）** 组件被创建。

##### This Binding

- **全局**执行上下文中，`this` 的值指向`全局对象`，在浏览器中`this` 的值指向 `window`对象，而在`nodejs`中指向`global`。
- **函数**执行上下文中，`this` 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定、`new`绑定、箭头函数。

##### 词法环境（Lexical Environment）

词法环境有两个**组成部分**

- **环境记录**：存储变量和函数声明的实际位置
- **对外部环境的引用**：可以访问其外部词法环境，`全局执行上下文`的外部引用为null

词法环境有两种**类型**

- **全局环境**：是一个没有外部环境的词法环境，其外部环境引用为 **null**。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，`this` 的值指向这个全局对象。
- **函数环境**：用户在函数中定义的变量被存储在**环境记录**中，包含了`arguments` 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。

##### 变量环境

变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。

在 ES6 中，**词法** 环境和 **变量** 环境的区别在于前者用于存储**函数声明和变量（ `let` 和 `const` ）**绑定，而后者仅用于存储**变量（ `var` ）**绑定。

#### 执行阶段

- 此阶段，完成对所有变量的分配，最后执行代码。

- 如果 Javascript 引擎在源代码中声明的实际位置找不到 `let` 变量的值，那么将为其分配 `undefined` 值。